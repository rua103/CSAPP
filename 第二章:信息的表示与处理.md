# 整数的补码与反码

一个数的构成为 **最高符号位+二进制编码**,反码直接对每一位数直接进行非(!)的操作
<img width="908" height="411" alt="image" src="https://github.com/user-attachments/assets/c6b89282-c028-42e5-aa94-b1cacc497776" />
<img width="588" height="230" alt="联想截图_20250926200935" src="https://github.com/user-attachments/assets/c7101862-7417-424a-8a00-73decb55f7c0" />



**补码的实质是最高符号位为1时,最高位为负,加上后面的各个位**

有无符号的小习题

<img width="826" height="621" alt="image" src="https://github.com/user-attachments/assets/4aaa60ba-3a61-489c-8a70-dd855fba0ea9" />

4.ux > -1

>wrong ux为无符号整型,会将-1转化为无符号整型,转换为0xFFFFFFFF,x肯定小于它

5.if x > y => -x <-y

>wrong 如果x为0,y为tTmin(eg.10000000),当y取负数时,发生整型溢出,仍等于(10000000),不成立

8和9 当x>=0时,不会产生特殊情况,当x<0时,考虑Tmin

10.(x|-x)>>31,得到的是最高的符号位,当x=0时,结果为0;当x!=0时,结果为-1

11和12 当为无符号整型时成立,当有符号时,右移补充的是符号位

13.**x&x-1**这是一个非常重要的位运算操作,在补码体系下稳定可靠.可以消除x二进制编码下最右边的1,可以用来判断一个数是不是2的幂次方

# 浮点数
<img width="623" height="295" alt="联想截图_20250927154444" src="https://github.com/user-attachments/assets/6cb982a1-2b0c-4df9-a35b-efa2862556a9" />

<img width="924" height="147" alt="image" src="https://github.com/user-attachments/assets/0f7c61f2-a863-40d3-8b5d-f6596bf4c798" />

## 为什么阶码=exp-bias,bias有什么用
<img width="740" height="279" alt="联想截图_20250927154820" src="https://github.com/user-attachments/assets/f3ddec7a-1f1e-43c8-ab8e-603052593dd3" />

<img width="624" height="448" alt="联想截图_20250927155411" src="https://github.com/user-attachments/assets/96876200-bedb-4d8e-ae09-b23ef70f1ea3" />

## 整型与浮点数之间的转换
### PUZZLES
<img width="1070" height="656" alt="图片" src="https://github.com/user-attachments/assets/d0c91f64-610c-41a1-bfef-f9889bb0c91b" />

float只有24个bits存储数据,int为31位,当把int转化为float会产生溢出

浮点数的运算(使用直接相加,会损失精度)
```
// 有问题的版本 
#include <stdio.h>
int main() {
    float sum = 0.0f;
    for (int i = 0; i < 10000; i++) sum += i + 1;
      printf("Sum: %f\n", sum);
    return 0;
}
// 1 + 2 + 3 + … + 10000 = 10000 * (10000 + 1) / 2 = 50005000 ?

// 修正的版本
#include <stdio.h>
int main() {
    float sum = 0.0f, corr = 0.0f; /*corr用于记录误差*/
    for (int i = 0; i < 10000; i++) {
      float y = (i + 1) - corr; /*加上上一次循环留下的误差*/
      float t = sum + y; /*这一次的运算可能产生误差值*/
      corr = (t - sum) - y; /*求出本次的误差值,再减去真实值,记录误差值*/
      sum = t;
    }
    printf("Sum: %f\n", sum);
    return 0;
}
```
```
/*过于优雅,不使用虚拟头节点*/
void remove_list_node(List *list, Node *target) {
    Node **indirect = &list->head; // indirect 指向头指针的地址
    while (*indirect != target)    // 比较 indirect 所指向的指针（即当前节点的地址）是否等于 target
        indirect = &(*indirect)->next; // 让 indirect 指向当前节点的 next 指针的地址
    *indirect = target->next; // 将指向 target 的指针，改为指向 target->next
}
```


