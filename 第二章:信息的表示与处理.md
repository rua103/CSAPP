一个数的构成为 **最高符号位+二进制编码**,反码直接对每一位数直接进行非(!)的操作
<img width="908" height="411" alt="image" src="https://github.com/user-attachments/assets/c6b89282-c028-42e5-aa94-b1cacc497776" />
<img width="588" height="230" alt="联想截图_20250926200935" src="https://github.com/user-attachments/assets/c7101862-7417-424a-8a00-73decb55f7c0" />



**补码的实质是最高符号位为1时,最高位为负,加上后面的各个位**

有无符号的小习题

<img width="826" height="621" alt="image" src="https://github.com/user-attachments/assets/4aaa60ba-3a61-489c-8a70-dd855fba0ea9" />

4.ux > -1

>wrong ux为无符号整型,会将-1转化为无符号整型,转换为0xFFFFFFFF,x肯定小于它

5.if x > y => -x <-y

>wrong 如果x为0,y为tTmin(eg.10000000),当y取负数时,发生整型溢出,仍等于(10000000),不成立

8和9 当x>=0时,不会产生特殊情况,当x<0时,考虑Tmin

10.(x|-x)>>31,得到的是最高的符号位,当x=0时,结果为0;当x!=0时,结果为-1

11和12 当为无符号整型时成立,当有符号时,右移补充的是符号位

13.**x&x-1**这是一个非常重要的位运算操作,在补码体系下稳定可靠.可以消除x二进制编码下最右边的1,可以用来判断一个数是不是2的幂次方
